// Copyright (c) 2024 The Stdlib Authors. License is Apache-2.0: http://www.apache.org/licenses/LICENSE-2.0
/// <reference types="./index.d.ts" />
import{isPrimitive as t}from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-positive-integer@v0.1.0-esm/index.mjs";import e from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-vector-like@v0.1.0-esm/index.mjs";import s from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-ndarray-like@v0.1.0-esm/index.mjs";import i from"https://cdn.jsdelivr.net/gh/stdlib-js/utils-define-nonenumerable-read-only-property@v0.1.0-esm/index.mjs";import n from"https://cdn.jsdelivr.net/gh/stdlib-js/string-format@v0.1.1-esm/index.mjs";import r from"https://cdn.jsdelivr.net/gh/stdlib-js/utils-define-nonenumerable-read-only-accessor@v0.1.0-esm/index.mjs";import{ndarray as a}from"https://cdn.jsdelivr.net/gh/stdlib-js/blas-base-gdot@v0.1.1-esm/index.mjs";import{ndarray as o}from"https://cdn.jsdelivr.net/gh/stdlib-js/blas-base-gaxpy@v0.1.1-esm/index.mjs";import l from"https://cdn.jsdelivr.net/gh/stdlib-js/blas-base-dcopy@v0.1.1-esm/index.mjs";import d from"https://cdn.jsdelivr.net/gh/stdlib-js/blas-base-dscal@v0.1.1-esm/index.mjs";import p from"https://cdn.jsdelivr.net/gh/stdlib-js/math-base-special-max@v0.1.1-esm/index.mjs";import h from"https://cdn.jsdelivr.net/gh/stdlib-js/math-base-special-exp@v0.1.0-esm/index.mjs";import m from"https://cdn.jsdelivr.net/gh/stdlib-js/math-base-special-pow@v0.1.0-esm/index.mjs";import g from"https://cdn.jsdelivr.net/gh/stdlib-js/math-base-special-expit@v0.1.0-esm/index.mjs";import c from"https://cdn.jsdelivr.net/gh/stdlib-js/array-float64@v0.1.1-esm/index.mjs";import u from"https://cdn.jsdelivr.net/gh/stdlib-js/ndarray-ctor@esm/index.mjs";import f from"https://cdn.jsdelivr.net/gh/stdlib-js/ndarray-base-shape2strides@v0.1.1-esm/index.mjs";import v from"https://cdn.jsdelivr.net/gh/stdlib-js/ndarray-base-numel@v0.1.1-esm/index.mjs";import b from"https://cdn.jsdelivr.net/gh/stdlib-js/ndarray-base-vind2bind@v0.1.1-esm/index.mjs";import{isPrimitive as j}from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-nonnegative-number@v0.1.1-esm/index.mjs";import{isPrimitive as _}from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-positive-number@v0.1.1-esm/index.mjs";import{isPrimitive as y}from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-number@v0.1.1-esm/index.mjs";import{isPrimitive as w}from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-boolean@v0.1.1-esm/index.mjs";import R from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-array-like-object@v0.1.0-esm/index.mjs";import x from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-is-plain-object@v0.1.0-esm/index.mjs";import L from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-has-own-property@v0.1.1-esm/index.mjs";import E from"https://cdn.jsdelivr.net/gh/stdlib-js/assert-contains@esm/index.mjs";var T={basic:"_basicLearningRate",constant:"_constantLearningRate",invscaling:"_inverseScalingLearningRate",pegasos:"_pegasosLearningRate"},F={hinge:"_hingeLoss",log:"_logLoss",modifiedHuber:"_modifiedHuberLoss",perceptron:"_perceptronLoss",squaredHinge:"_squaredHingeLoss"};function H(t,e){var s;return this._N=t,this._opts=e,this._scaleFactor=1,this._t=0,this._learningRateMethod=T[e.learningRate[0]],this._lossMethod=F[e.loss],s=t,e.intercept&&(s+=1),this._weights=new c(s),this._coefficients=new u("float64",new c(s),[s],[1],0,"row-major"),this}i(H.prototype,"_add",(function(t,e){var s=e/this._scaleFactor,i=this._weights;return o(t.shape[0],s,t.data,t.strides[0],t.offset,i,1,0),this._opts.intercept&&(i[this._N]+=s),this})),i(H.prototype,"_basicLearningRate",(function(){return 10/(10+this._t)})),i(H.prototype,"_constantLearningRate",(function(){return this._opts.learningRate[1]})),i(H.prototype,"_dot",(function(t,e,s){var i=a(this._N,this._weights,1,0,t,e,s);return this._opts.intercept&&(i+=this._weights[this._N]),i*=this._scaleFactor})),i(H.prototype,"_hingeLoss",(function(t,e){var s;return s=this[this._learningRateMethod](),this._regularize(s),e*this._dot(t.data,t.strides[0],t.offset)<1&&this._add(t,e*s),this})),i(H.prototype,"_inverseScalingLearningRate",(function(){var t=this._opts.learningRate;return t[1]/m(this._t,t[2])})),i(H.prototype,"_logLoss",(function(t,e){var s,i,n;return i=this[this._learningRateMethod](),this._regularize(i),n=this._dot(t.data,t.strides[0],t.offset),s=e/(1+h(e*n)),this._add(t,i*s),this})),i(H.prototype,"_modifiedHuberLoss",(function(t,e){var s,i;return s=this[this._learningRateMethod](),this._regularize(s),(i=e*this._dot(t.data,t.strides[0],t.offset))<-1?this._add(t,4*s*e):this._add(t,s*(e-i*e)),this})),i(H.prototype,"_pegasosLearningRate",(function(){return 1/(this._opts.lambda*this._t)})),i(H.prototype,"_perceptronLoss",(function(t,e){var s;return s=this[this._learningRateMethod](),this._regularize(s),e*this._dot(t.data,t.strides[0],t.offset)<=0&&this._add(t,e*s),this})),i(H.prototype,"_regularize",(function(t){var e=this._opts.lambda;return e<=0||this._scale(p(1-t*e,1e-7)),this})),i(H.prototype,"_scale",(function(t){var e;if(t<=0)throw new RangeError(n("invalid argument. Attempting to scale a weight vector by a nonpositive value. This is likely due to too large a value of eta * lambda. Value: `%f`.",t));return(e=this._scaleFactor)<1e-11&&(d(this._N,e,this._weights,1),this._scaleFactor=1),this._scaleFactor*=t,this})),i(H.prototype,"_squaredHingeLoss",(function(t,e){var s,i;return s=this[this._learningRateMethod](),this._regularize(s),(i=e*this._dot(t.data,t.strides[0],t.offset))<1&&this._add(t,s*(e-i*e)),this})),r(H.prototype,"coefficients",(function(){var t=this._coefficients.data,e=this._weights;return l(e.length,e,1,t,1),d(this._N,this._scaleFactor,t,1),this._coefficients})),r(H.prototype,"nfeatures",(function(){return this._N})),i(H.prototype,"predict",(function(t,e){var s,i,n,r,a,o,l,d,p,h,m,j,_,y,w,R;for(i=t.data,r=t.shape,p=t.strides,m=t.offset,o=t.order,s=r.length-1,a=[],R=0;R<s;R++)a.push(r[R]);for(0===s?(j=1,n=new c(1),h=[0]):(j=v(a),n=new c(j),h=f(a,o)),y=new u("int8",n,a,h,0,o),_=this._N,d=p[s],R=0;R<j;R++)l=b(r,p,m,o,R*_,"throw"),w=this._dot(i,d,l),"label"===e?w=w>0?1:-1:"probability"===e&&(w=g(w)),0===s?y.iset(w):y.iset(R,w);return y})),i(H.prototype,"update",(function(t,e){return this._t+=1,this[this._lossMethod](t,e)}));var M={basic:["basic"],constant:["constant",.02],invscaling:["invscaling",.02,.5],pegasos:["pegasos"]},z=["basic","constant","invscaling","pegasos"],N=["hinge","log","modifiedHuber","perceptron","squaredHinge"];function O(t,e){var s;if(!x(e))return new TypeError(n("invalid argument. Options argument must be an object. Value: `%s`.",e));if(L(e,"intercept")&&(t.intercept=e.intercept,!w(t.intercept)))return new TypeError(n("invalid option. `%s` option must be a boolean. Option: `%s`.","intercept",t.intercept));if(L(e,"lambda")&&(t.lambda=e.lambda,!j(t.lambda)))return new TypeError(n("invalid option. `%s` option must be a nonnegative number. Option: `%s`.","lambda",t.lambda));if(L(e,"learningRate")){if(!R(e.learningRate))return new TypeError(n("invalid option. `%s` option must be an array-like object. Option: `%s`.","learningRate",e.learningRate));if(s=e.learningRate[0],t.learningRate[0]=s,!E(z,s))return new TypeError(n('invalid option. First `%s` option must be one of the following: "%s". Option: `%s`.',"learningRate",z.join('", "'),s));if(e.learningRate.length>1&&("constant"===s||"invscaling"===s)&&(t.learningRate[1]=e.learningRate[1],!_(t.learningRate[1])))return new TypeError(n("invalid option. Second `%s` option must be a positive number. Option: `%s`.","learningRate",t.learningRate[1]));if(e.learningRate.length>2&&"invscaling"===s&&(t.learningRate[2]=e.learningRate[2],!y(t.learningRate[2])))return new TypeError(n("invalid option. Third `%s` option must be a number. Option: `%s`.","learningRate",t.learningRate[2]))}return L(e,"loss")&&(t.loss=e.loss,!E(N,t.loss))?new TypeError(n('invalid option. `%s` option must be one of the following: "%s". Option: `%s`.',"loss",N.join('", "'),t.loss)):null}function V(r,a){var o,l,d;if(!t(r))throw new TypeError(n("invalid argument. First argument must be a positive integer. Value: `%s`.",r));if(l={intercept:!0,lambda:1e-4,learningRate:M.basic.slice(),loss:"log"},arguments.length>1&&(d=O(l,a)))throw d;return o=new H(r,l),i(p,"predict",h),p;function p(t,s){if(0===arguments.length)return o.coefficients;if(!e(t))throw new TypeError(n("invalid argument. First argument must be a one-dimensional ndarray. Value: `%s`.",t));if(-1!==s&&1!==s)throw new TypeError(n("invalid argument. Second argument must be either +1 or -1. Value: `%s`.",s));if(t.shape[0]!==o.nfeatures)throw new TypeError(n("invalid argument. First argument must be a one-dimensional ndarray of length %u. Actual length: `%u`.",o.nfeatures,t.shape[0]));return o.update(t,s),o.coefficients}function h(t,e){var i,a;if(!s(t))throw new TypeError(n("invalid argument. First argument must be an ndarray. Value: `%s`.",t));if((i=t.shape)[i.length-1]!==r)throw new TypeError(n("invalid argument. First argument must be an ndarray whose last dimension is of size %u. Actual size: `%u`.",r,i[i.length-1]));if(a="label",arguments.length>1){if("probability"===e){if("log"!==l.loss&&"modifiedHuber"!==l.loss)throw new Error(n('invalid argument. Second argument is incompatible with model loss function. Probability predictions are only supported when the loss function is one of the following: "%s". Model loss function: `%s`.',["log","modifiedHuber"].join('", "'),l.loss))}else if("label"!==e&&"linear"!==e)throw new TypeError(n('invalid argument. Second argument must be a string value equal to either "label", "probability", or "linear". Value: `%s`.',e));a=e}return o.predict(t,a)}}export{V as default};
//# sourceMappingURL=index.mjs.map
